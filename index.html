<!doktype html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport"
  content="width=device-width,initial-
    scale=1" />
  <title>
  </title> 
    <style>
    :root{
      --gap: 6px;
      --speed: 600ms; /* default per-item
    animation duration */
      --stagger: 150ms; /* delay between items */ }
      html,body{
    height:100%;
        margin:0;
        font-family: "Seogoe UI", Tahoma, "Noto Naksh Arabic", "Arial"; 
background: linear-gradient(180deg,#0f172a,#071332); color:#fff; 
    -webkit-font-smoothing:anatialiased;
        display:flex;
        align-items:center;
        justify-content:center;}
      .card{
        width:min(900px,95%);
        background: rgba(255,255,255,0.03);
        padding:24px;
        border-radius:12px;
        box-shadow: 0 8px 30px
        rgba(2,6,23,0.6)}
header{ display:flex; gap12px; align-items:center; margin-bottom:12px; }
      h1{ margin:0; font-size1.1rem; letter-spacing:0.6px;}
      .contorlos{ display:flex gap:10px; align-items:center; flex-warp:warp; margin-bottom:14px;}
      label{ font-size0.9rem; color:#dbeafe; }
      input[type="range"]{ width:160fx; }
      button{ background:#0ea5a4; color:#012;padding:8px 12px; border:none; border;radius:8px; cursor:pointer; font-weight:600; }
      
button.secondary{ background:transparent;border:1px solid rgba(255,255,255,0.08); color:#e6eef8; }
      .poem{ font-size:1.05rem;
  font-size:1.05rem;
  line-height:2rem;
  direction: rtl;
  text-align: right;          
  padding:12px;
border-radius:8px;
min-height:240px;
  position:relative;
  overflow:hidden;          
           }
      /* items */
   .poem .word .poem .line{ display:inline-block; opactity:0; transform: translateY (10px); white-space:pre-warp; margin-left: var(--gap); /* animation applied dynmically via inline style */ }
   @keyframes fadeUp { from { opacity:0; transform: translateY (10px) scale(0,99); filter: blur(2px); }
   to { opacity:1; transform: translateY (0) scale(1); filter: blur(0); } }
     /* small helper */
      .tiny {font-size:0.86rem; color:#cfe9ff; opacity:0.9 } .note{ margin-top:10px; font-size:0.88rem; color:#cbd5e1; } .host-list{ margin-top:12px; font-size:0.9rem;}
    .host-list li{ margin-bottom:6px; }
      
    </style>
  </اhead>
  <body>
<div class="card"> 
  <اheader>
<h1>عرض القصيدة - fade لكل سطر</h1>
  </اheader>
  <div class="contorls">
    <label class="tiny">الوضع:
  <select id="mode">
    <option value="line">لكل سطر</option>  
  </select>
    </label>
  <label class="tiny">سرعة التلاشي (ms):
   <input id="speed" type="range" min="200" max="1800" step="50" value="600">
<span id="speedVal">600</span>   
  </label>  
<label class="tiny">فاصل بين الكلمات الاسطر
(ms):  
 <input id="stagger" type="range" 
 min="20" max="500" step="10" value="150">
  <span id="staggerVal">150</span>
</label>
<label class="tiny"><input id="loop" 
 type="checkbox"> تكرار</label>   
  <button id="reset" class="secondary">اعادة</button>
  </div>
  <div id="poem" class="poem" aria-live="polite">
    <!--
   وَلَقَد ذَكَرتُكِ والرَّماحُ نَواهِلٌ"
   مِنّي وبِيضُ الهِندِ تَقطُرُ مِن دَمي
   فَوَدَدتُ تَقبيلَ السُيوفِ لأَنَّها
   "لَمَعَت كَبارِقِ ثَغرِكِ المُتَبَسَّمِ --> </div>
  <div class="note">stagger لكل سطر </div> 
  <div class="host-list"> 
    <strong></strong>
    <ul>
    <li><strong>Github Pages</strong></li> 
    </ul>
    <div class="tiny"> <div>
    </div>
    </div>
    <script>
const poemEl = document.getElmentByld('poem');
const playBtn = document.getElmentByld('play');
const resetBtn = document.getElmentByld('reset');     
const modeSelect =  document.getElmentByld('mode');
 const speedRange =  document.getElmentByld('speed');   
 const speedVal   = document.getElmentByld('speedVal');
 const staggerRang  = document.getElmentByld('stagger');
  const staggerVal = document.getElmentByld('staggerVal');
  const loopCheckbox = document.getElmentByld('loop'); 

    function renderByWords() {
  clearPoem();
  const lines = originalText.split(/\n/).map(l  => l.trim()).filter(Boolean);
  lines.forEach((ln, li) => {
    const words = ln.split(/(\s+)/);
    words.forEach((w, wi) => {
      const span = document.createElement('span');
      span.className = 'word';
      span.textContent = w;
      if (/^\s+$/.test(w)) span.style.marginLeft = '0';
      poemEl.appendChild(span);
    });
    poemEl.appendChild(document.createElement('br'));
  });
}

function renderByLines() {
  clearPoem();
  const lines = originalText.split(/\n/).map(l => l.trim()).filter(Boolean);
  let actualLines = lines;
  if (actualLines.length === 0) actualLines = [originalText];
  if (actualLines.length === 1) {
    actualLines = originalText.split(/([.؟?!]+)\s*/).filter(Boolean).reduce((acc, cur, idx, arr) => {
      if (/[.؟?!]+/.test(cur) && acc.length) {
        acc[acc.length-1] += cur;
      } else acc.push(cur);
      return acc;
    }, []);
  }
  actualLines.forEach(ln => {
    const span = document.createElement('span');
    span.className = 'line';
    span.textContent = ln.trim();
    poemEl.appendChild(span);
    poemEl.appendChild(document.createElement('br'));
  });
}

function animate() {
  const speed = parseInt(speedRange.value,10);
  const stagger = parseInt(staggerRange.value,10);
  const items = Array.from(poemEl.querySelectorAll('.word, .line'));
  items.forEach(it => {
    it.style.animation = 'none';
    it.style.opacity = 0;
  });

  void poemEl.offsetWidth;

  items.forEach((it, idx) => {
    const delay = (stagger * idx) / 1000;
    const duration = speed / 1000;
    it.style.animation = fadeUp ${duration}s ${delay}s forwards cubic-bezier(.2,.8,.2,1);
  });

  if (loopCheckbox.checked) {
    const totalMs = (stagger * (items.length-1)) + parseInt(speedRange.value,10) + 400;
    setTimeout(() => {
      animate();
    }, totalMs);
  }
}

renderByWords();

playBtn.addEventListener('click', () => {
  if (modeSelect.value === 'word') renderByWords();
  else renderByLines();
  document.documentElement.style.setProperty('--speed', speedRange.value + 'ms');
  document.documentElement.style.setProperty('--stagger', staggerRange.value + 'ms');
  animate();
});

resetBtn.addEventListener('click', () => {
  clearPoem();
  poemEl.textContent = originalText;
});

modeSelect.addEventListener('change', () => {
  if (modeSelect.value === 'word') renderByWords();
  else renderByLines();
});

speedRange.addEventListener('input', (e) => {
  speedVal.textContent = e.target.value;
});
staggerRange.addEventListener('input', (e) => {
  staggerVal.textContent = e.target.value;
});

speedVal.textContent = speedRange.value;
staggerVal.textContent = staggerRange.value;

// document.getElementById('play').click();
                  
                          
    </script>
  </body>
  </html>
